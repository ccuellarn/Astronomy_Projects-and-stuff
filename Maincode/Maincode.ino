// Talkie library
// Copyright 2011 Peter Knight
// This code is released under GPLv2 license.

#if (ARDUINO >= 100)
 #include "Arduino.h"
#else
 #include <avr/io.h>
 #include "WProgram.h"
#endif

#ifndef _Talkie_h_
#define _Talkie_h_
class Talkie
{
	public:
		void say(uint8_t* address);
		uint8_t* ptrAddr;
		uint8_t ptrBit;
	private:
		// Setup
		uint8_t setup;
		
		// Bitstream parser
		void setPtr(uint8_t* addr);
		uint8_t rev(uint8_t a);
		uint8_t getBits(uint8_t bits);
};


#endif

#define FS 8000 // Speech engine sample rate

uint8_t synthPeriod;
uint16_t synthEnergy;
int16_t synthK1,synthK2;
int8_t synthK3,synthK4,synthK5,synthK6,synthK7,synthK8,synthK9,synthK10;

uint8_t tmsEnergy[0x10] = {0x00,0x02,0x03,0x04,0x05,0x07,0x0a,0x0f,0x14,0x20,0x29,0x39,0x51,0x72,0xa1,0xff};
uint8_t tmsPeriod[0x40] = {0x00,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2D,0x2F,0x31,0x33,0x35,0x36,0x39,0x3B,0x3D,0x3F,0x42,0x45,0x47,0x49,0x4D,0x4F,0x51,0x55,0x57,0x5C,0x5F,0x63,0x66,0x6A,0x6E,0x73,0x77,0x7B,0x80,0x85,0x8A,0x8F,0x95,0x9A,0xA0};
int16_t tmsK1[0x20]     = {0x82C0,0x8380,0x83C0,0x8440,0x84C0,0x8540,0x8600,0x8780,0x8880,0x8980,0x8AC0,0x8C00,0x8D40,0x8F00,0x90C0,0x92C0,0x9900,0xA140,0xAB80,0xB840,0xC740,0xD8C0,0xEBC0,0x0000,0x1440,0x2740,0x38C0,0x47C0,0x5480,0x5EC0,0x6700,0x6D40};
int16_t tmsK2[0x20]     = {0xAE00,0xB480,0xBB80,0xC340,0xCB80,0xD440,0xDDC0,0xE780,0xF180,0xFBC0,0x0600,0x1040,0x1A40,0x2400,0x2D40,0x3600,0x3E40,0x45C0,0x4CC0,0x5300,0x5880,0x5DC0,0x6240,0x6640,0x69C0,0x6CC0,0x6F80,0x71C0,0x73C0,0x7580,0x7700,0x7E80};
int8_t tmsK3[0x10]      = {0x92,0x9F,0xAD,0xBA,0xC8,0xD5,0xE3,0xF0,0xFE,0x0B,0x19,0x26,0x34,0x41,0x4F,0x5C};
int8_t tmsK4[0x10]      = {0xAE,0xBC,0xCA,0xD8,0xE6,0xF4,0x01,0x0F,0x1D,0x2B,0x39,0x47,0x55,0x63,0x71,0x7E};
int8_t tmsK5[0x10]      = {0xAE,0xBA,0xC5,0xD1,0xDD,0xE8,0xF4,0xFF,0x0B,0x17,0x22,0x2E,0x39,0x45,0x51,0x5C};
int8_t tmsK6[0x10]      = {0xC0,0xCB,0xD6,0xE1,0xEC,0xF7,0x03,0x0E,0x19,0x24,0x2F,0x3A,0x45,0x50,0x5B,0x66};
int8_t tmsK7[0x10]      = {0xB3,0xBF,0xCB,0xD7,0xE3,0xEF,0xFB,0x07,0x13,0x1F,0x2B,0x37,0x43,0x4F,0x5A,0x66};
int8_t tmsK8[0x08]      = {0xC0,0xD8,0xF0,0x07,0x1F,0x37,0x4F,0x66};
int8_t tmsK9[0x08]      = {0xC0,0xD4,0xE8,0xFC,0x10,0x25,0x39,0x4D};
int8_t tmsK10[0x08]     = {0xCD,0xDF,0xF1,0x04,0x16,0x20,0x3B,0x4D};

void Talkie::setPtr(uint8_t* addr) {
	ptrAddr = addr;
	ptrBit = 0;
}

// The ROMs used with the TI speech were serial, not byte wide.
// Here's a handy routine to flip ROM data which is usually reversed.
uint8_t Talkie::rev(uint8_t a) {
	// 76543210
	a = (a>>4) | (a<<4); // Swap in groups of 4
	// 32107654
	a = ((a & 0xcc)>>2) | ((a & 0x33)<<2); // Swap in groups of 2
	// 10325476
	a = ((a & 0xaa)>>1) | ((a & 0x55)<<1); // Swap bit pairs
	// 01234567
	return a;
}
uint8_t Talkie::getBits(uint8_t bits) {
	uint8_t value;
	uint16_t data;
	data = rev(pgm_read_byte(ptrAddr))<<8;
	if (ptrBit+bits > 8) {
		data |= rev(pgm_read_byte(ptrAddr+1));
	}
	data <<= ptrBit;
	value = data >> (16-bits);
	ptrBit += bits;
	if (ptrBit >= 8) {
		ptrBit -= 8;
		ptrAddr++;
	}
	return value;
}
void Talkie::say(uint8_t* addr) {
	uint8_t energy;

	if (!setup) {
		// Auto-setup.
		// 
		// Enable the speech system whenever say() is called.
		
		pinMode(3,OUTPUT);
		// Timer 2 set up as a 62500Hz PWM.
		//
		// The PWM 'buzz' is well above human hearing range and is
		// very easy to filter out.
		//
		TCCR2A = _BV(COM2B1) | _BV(WGM21) | _BV(WGM20);
		TCCR2B = _BV(CS20);
		TIMSK2 = 0;
	
		// Unfortunately we can't calculate the next sample every PWM cycle
		// as the routine is too slow. So use Timer 1 to trigger that.
		
		// Timer 1 set up as a 8000Hz sample interrupt
		TCCR1A = 0;
		TCCR1B = _BV(WGM12) | _BV(CS10);
		TCNT1 = 0;
		OCR1A = F_CPU / FS;
		TIMSK1 = _BV(OCIE1A);

		setup = 1;
	}

	setPtr(addr);
	do {
		uint8_t repeat;

		// Read speech data, processing the variable size frames.
		
		energy = getBits(4);
		if (energy == 0) {
			// Energy = 0: rest frame
			synthEnergy = 0;
		} else if (energy == 0xf) {
			// Energy = 15: stop frame. Silence the synthesiser.
			synthEnergy = 0;
			synthK1 = 0;
			synthK2 = 0;
			synthK3 = 0;
			synthK4 = 0;
			synthK5 = 0;
			synthK6 = 0;
			synthK7 = 0;
			synthK8 = 0;
			synthK9 = 0;
			synthK10 = 0;
		} else {
			synthEnergy = tmsEnergy[energy];
			repeat = getBits(1);
			synthPeriod = tmsPeriod[getBits(6)];
			// A repeat frame uses the last coefficients
			if (!repeat) {
				// All frames use the first 4 coefficients
				synthK1 = tmsK1[getBits(5)];
				synthK2 = tmsK2[getBits(5)];
				synthK3 = tmsK3[getBits(4)];
				synthK4 = tmsK4[getBits(4)];
				if (synthPeriod) {
					// Voiced frames use 6 extra coefficients.
					synthK5 = tmsK5[getBits(4)];
					synthK6 = tmsK6[getBits(4)];
					synthK7 = tmsK7[getBits(4)];
					synthK8 = tmsK8[getBits(3)];
					synthK9 = tmsK9[getBits(3)];
					synthK10 = tmsK10[getBits(3)];
				}
			}
		}
		delay(25);
	} while (energy != 0xf);
}

#define CHIRP_SIZE 41
int8_t chirp[CHIRP_SIZE] = {0x00,0x2a,0xd4,0x32,0xb2,0x12,0x25,0x14,0x02,0xe1,0xc5,0x02,0x5f,0x5a,0x05,0x0f,0x26,0xfc,0xa5,0xa5,0xd6,0xdd,0xdc,0xfc,0x25,0x2b,0x22,0x21,0x0f,0xff,0xf8,0xee,0xed,0xef,0xf7,0xf6,0xfa,0x00,0x03,0x02,0x01};

ISR(TIMER1_COMPA_vect) {
  static uint8_t nextPwm;
  static uint8_t periodCounter;
  static int16_t x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10;
  int16_t u0,u1,u2,u3,u4,u5,u6,u7,u8,u9,u10;

  OCR2B = nextPwm;
  sei();
  if (synthPeriod) {
    // Voiced source
    if (periodCounter < synthPeriod) {
      periodCounter++;
    } else {
      periodCounter = 0;
    }
    if (periodCounter < CHIRP_SIZE) {
      u10 = ((chirp[periodCounter]) * (uint32_t) synthEnergy) >> 8;
    } else {
      u10 = 0;
    }
  } else {
    // Unvoiced source
    static uint16_t synthRand = 1;
    synthRand = (synthRand >> 1) ^ ((synthRand & 1) ? 0xB800 : 0);
    u10 = (synthRand & 1) ? synthEnergy : -synthEnergy;
  }
  // Lattice filter forward path
  u9 = u10 - (((int16_t)synthK10*x9) >> 7);
  u8 = u9 - (((int16_t)synthK9*x8) >> 7);
  u7 = u8 - (((int16_t)synthK8*x7) >> 7);
  u6 = u7 - (((int16_t)synthK7*x6) >> 7);
  u5 = u6 - (((int16_t)synthK6*x5) >> 7);
  u4 = u5 - (((int16_t)synthK5*x4) >> 7);
  u3 = u4 - (((int16_t)synthK4*x3) >> 7);
  u2 = u3 - (((int16_t)synthK3*x2) >> 7);
  u1 = u2 - (((int32_t)synthK2*x1) >> 15);
  u0 = u1 - (((int32_t)synthK1*x0) >> 15);

  // Output clamp
  if (u0 > 511) u0 = 511;
  if (u0 < -512) u0 = -512;
  
  // Lattice filter reverse path
  x9 = x8 + (((int16_t)synthK9*u8) >> 7);
  x8 = x7 + (((int16_t)synthK8*u7) >> 7);
  x7 = x6 + (((int16_t)synthK7*u6) >> 7);
  x6 = x5 + (((int16_t)synthK6*u5) >> 7);
  x5 = x4 + (((int16_t)synthK5*u4) >> 7);
  x4 = x3 + (((int16_t)synthK4*u3) >> 7);
  x3 = x2 + (((int16_t)synthK3*u2) >> 7);
  x2 = x1 + (((int32_t)synthK2*u1) >> 15);
  x1 = x0 + (((int32_t)synthK1*u0) >> 15);
  x0 = u0;

  nextPwm = (u0>>2)+0x80;
}


Talkie voice;
const uint8_t spHELLO[]             PROGMEM ={0x00,0xC0,0x80,0x60,0x59,0x08,0x10,0x3D,0xB7,0x00,0x62,0x64,0x3D,0x55,0x4A,0x9E,0x66,0xDA,0xF6,0x56,0xB7,0x3A,0x55,0x76,0xDA,0xED,0x92,0x75,0x57,0xA3,0x88,0xA8,0xAB,0x02,0xB2,0xF4,0xAC,0x67,0x23,0x73,0xC6,0x2F,0x0C,0xF3,0xED,0x62,0xD7,0xAD,0x13,0xA5,0x46,0x8C,0x57,0xD7,0x21,0x0C,0x22,0x4F,0x93,0x4B,0x27,0x37,0xF0,0x51,0x69,0x98,0x9D,0xD4,0xC8,0xFB,0xB8,0x98,0xB9,0x56,0x23,0x2F,0x93,0xAA,0xE2,0x46,0x8C,0x52,0x57,0x66,0x2B,0x8C,0x07};
const uint8_t spYOU[]               PROGMEM ={0xA5,0xDA,0x0D,0x98,0x23,0x6F,0xF4,0x6A,0x55,0x33,0xA9,0x82,0xC6,0xEB,0x91,0xF5,0x68,0x02,0x11,0x5B,0x67,0x36,0x32,0x2B,0xA2,0x24,0x75,0x75,0xCF,0x7B,0xD5,0x9B,0xD6,0x5A,0x61,0xE5,0x49,0xDD,0x6A,0x97,0xFB,0xD8,0xFB,0x5E,0x77,0xA2,0xB3,0x2C,0x45,0x25,0x8D,0x3C,0x00,0x00};
const uint8_t spYES[]               PROGMEM ={0xAA,0x9A,0x0E,0x54,0x6A,0x26,0xC7,0xA6,0xB6,0xAB,0x9D,0xD5,0x0D,0xD8,0xDE,0x9E,0xA6,0x44,0x57,0x8D,0x78,0x73,0xDB,0xD3,0x96,0xEC,0xAE,0xE6,0x4B,0x57,0x1B,0x9B,0x27,0xEB,0xDA,0x9D,0x75,0xAB,0xC2,0x88,0x44,0x6B,0x3B,0xA1,0xB2,0xD1,0x55,0xAC,0x23,0xC4,0xDC,0x00,0xDF,0x88,0x69,0x40,0x03,0x12,0xE0,0x00,0x05,0x28,0x80,0x81,0x07};
const uint8_t spI[]                 PROGMEM ={0x23,0x09,0xDE,0x27,0x82,0xBB,0xED,0xEC,0x16,0xB7,0xBE,0xF5,0x6D,0x4E,0x13,0xB2,0x97,0x5B,0xB4,0xDD,0xDD,0xEA,0x42,0xF6,0x70,0x8F,0x39,0xAD,0x8F,0x85,0xDB,0xBC,0xCB,0x94,0x3E,0x64,0xD5,0x1C,0x0B,0x95,0x07,0x37,0x78,0x27,0xB9,0xA9,0x86,0x4D,0x1F,0x3C,0xD3,0xA4,0x1B,0x96,0x35,0xAF,0xE1,0x01,0x00,0x00};
const uint8_t spLOAD[]              PROGMEM ={0x21,0x37,0xCA,0x63,0xC1,0xBC,0xB5,0xDE,0x1B,0x9A,0x46,0xF3,0xD6,0xDA,0xE4,0xA0,0x87,0x32,0xDF,0xAA,0xA2,0x95,0x3D,0xCA,0x7C,0xAB,0x32,0xC6,0x7F,0x20,0xF3,0x8D,0x42,0x85,0xDE,0x02,0xC9,0x36,0x0A,0x1D,0x7B,0x0A,0xD1,0x7F,0xAB,0x94,0xEF,0x29,0x42,0xFF,0xAD,0x52,0xA6,0xA7,0x08,0xBB,0xB6,0x46,0x9B,0xD8,0x44,0xCC,0x57,0x3A,0xAB,0x7D,0xDD,0xA0,0x4F,0xEA,0xAD,0x8C,0x63,0x87,0xDE,0x69,0x74,0xCA,0x26,0x12,0xFA,0xA4,0xC9,0x5A,0x9E,0x71,0xF1,0x1C,0x26,0x6F,0xA8,0x2A,0x31,0x15,0x9B,0xA8,0x8A,0x6C,0xCB,0x54,0x6A,0xA2,0xB2,0xCA,0x7C,0x14,0xB1,0x89,0xCA,0xC8,0x74,0x75,0x12,0xA6,0xEE,0xC2,0x45,0x25,0xA9,0xED,0x44,0x9B,0x83,0xB9,0x73,0xA6,0x42,0x7D,0xB6,0x6E,0x06,0xA4,0xE4,0x01,0x00,0x00};
const uint8_t spMOTOR[]  PROGMEM = {0x66, 0xAA, 0x8C, 0x69, 0x53, 0x92, 0xC4, 0x2D, 0x2F, 0x6B, 0x2A, 0x74, 0xDA, 0x9D, 0xB2, 0xDD, 0xF6, 0x36, 0xAB, 0xCE, 0x78, 0xDA, 0x9D, 0xB2, 0xD5, 0x9A, 0x01, 0xDB, 0x77, 0x45, 0xA0, 0x75, 0xC5, 0xB8, 0x71, 0x59, 0xDA, 0x31, 0xE5, 0x6A, 0x22, 0x63, 0xDE, 0xDA, 0x9A, 0xBB, 0xA3, 0x75, 0x68, 0xAF, 0x7B, 0x3E, 0xC3, 0x9D, 0x97, 0x60, 0x87, 0xE6, 0x8B, 0x4F, 0x78, 0x4B, 0x76, 0xB2, 0x09, 0xAF, 0xFE, 0xFD, 0x7F};
const uint8_t spDANGER[] PROGMEM = {0x2D, 0xBF, 0x21, 0x92, 0x59, 0xB4, 0x9F, 0xA2, 0x87, 0x10, 0x8E, 0xDC, 0x72, 0xAB, 0x5B, 0x9D, 0x62, 0xA6, 0x42, 0x9E, 0x9C, 0xB8, 0xB3, 0x95, 0x0D, 0xAF, 0x14, 0x15, 0xA5, 0x47, 0xDE, 0x1D, 0x7A, 0x78, 0x3A, 0x49, 0x65, 0x55, 0xD0, 0x5E, 0xAE, 0x3A, 0xB5, 0x53, 0x93, 0x88, 0x65, 0xE2, 0x00, 0xEC, 0x9A, 0xEA, 0x80, 0x65, 0x82, 0xC7, 0xD8, 0x63, 0x0A, 0x9A, 0x65, 0x5D, 0x53, 0xC9, 0x49, 0x5C, 0xE1, 0x7D, 0x2F, 0x73, 0x2F, 0x47, 0x59, 0xC2, 0xDE, 0x9A, 0x27, 0x5F, 0xF1, 0x8B, 0xDF, 0xFF, 0x03};
const uint8_t spON[]     PROGMEM = {0x65, 0x4A, 0xEA, 0x3A, 0x5C, 0xB2, 0xCE, 0x6E, 0x57, 0xA7, 0x48, 0xE6, 0xD2, 0x5D, 0xBB, 0xEC, 0x62, 0x17, 0xBB, 0xDE, 0x7D, 0x9F, 0xDA, 0x5C, 0x5C, 0x7A, 0xAA, 0xB5, 0x6E, 0xCB, 0xD0, 0x0E, 0xAD, 0x6E, 0xAF, 0xEE, 0xF9, 0x88, 0x67, 0xBC, 0xDC, 0x3D, 0xAC, 0x60, 0xB8, 0x45, 0xF3, 0xB7, 0xBF, 0xC3, 0xDD, 0xA2, 0xBB, 0xAB, 0xCD, 0x89, 0x8F, 0x7F, 0xFE, 0x1F};
const uint8_t spRED[]    PROGMEM = {0x6A, 0xB5, 0xD9, 0x25, 0x4A, 0xE5, 0xDB, 0xC5, 0x4F, 0x6D, 0x88, 0x95, 0x2D, 0xD2, 0xB4, 0x8F, 0x2E, 0x37, 0x0E, 0x33, 0xCF, 0x7E, 0xAA, 0x9A, 0x5C, 0xC3, 0xB4, 0xCB, 0xA9, 0x86, 0x69, 0x76, 0xD3, 0x37, 0xB7, 0xBE, 0xCD, 0xED, 0xEF, 0xB4, 0xB7, 0xB0, 0x35, 0x69, 0x94, 0x22, 0x6D, 0x10, 0x28, 0x42, 0xB9, 0x8B, 0xC8, 0x06, 0x00, 0x50, 0xCF, 0x0E, 0xEE, 0x62, 0xEA, 0xA6, 0xBC, 0xC3, 0x14, 0xBB, 0x4A, 0x9F, 0xFA, 0xA5, 0xAF, 0x25, 0x13, 0x17, 0xDF, 0x9C, 0xBF, 0xFF, 0x07};
const uint8_t spIS[]     PROGMEM = {0xAD, 0xED, 0xD5, 0x58, 0xA4, 0x9E, 0xCE, 0x76, 0xF5, 0xDD, 0xAB, 0x29, 0xF5, 0xD2, 0xDD, 0xEF, 0x7E, 0x0C, 0xC3, 0xA9, 0x06, 0xFA, 0xD3, 0x32, 0x0F, 0x6E, 0x94, 0x22, 0x8F, 0xF3, 0x92, 0xF6, 0x05, 0x43, 0xCC, 0x74, 0x77, 0x3E, 0xC3, 0xF5, 0x95, 0x98, 0xA9, 0xBA, 0x8B, 0x8F, 0x00, 0x7E, 0x73, 0xE5, 0x00, 0x05, 0x28, 0xF0, 0xFF};
const uint8_t spALERT[]  PROGMEM = {0xA5, 0xCF, 0xC6, 0xAB, 0x55, 0x5B, 0xAF, 0x39, 0xDA, 0xC9, 0x54, 0xDD, 0xBC, 0xC6, 0xC2, 0x3C, 0x27, 0x20, 0xCF, 0x1C, 0xD7, 0x30, 0xB0, 0x45, 0x16, 0x69, 0x1D, 0xC3, 0x11, 0xE4, 0x59, 0x8A, 0x7C, 0xB5, 0x9B, 0x8B, 0xD9, 0x30, 0xB7, 0xD3, 0x76, 0x19, 0x9A, 0x25, 0x59, 0x57, 0x59, 0xEC, 0x11, 0xAF, 0xE8, 0xD9, 0xF9, 0x2A, 0x8A, 0x1D, 0xF0, 0x75, 0x3F, 0x73, 0xAC, 0x87, 0x3B, 0xA2, 0x0B, 0xAA, 0x2B, 0xCF, 0xE4, 0x10, 0xA1, 0xDC, 0x45, 0x64, 0x03, 0x00, 0x80, 0x01, 0x66, 0x36, 0x33, 0xC0, 0xAB, 0xD5, 0x0A, 0x68, 0x25, 0x85, 0x02, 0xFF, 0x0F};
const uint8_t spFIRE[]   PROGMEM = {0x04, 0x18, 0xCE, 0x4D, 0x02, 0x1A, 0xD0, 0x80, 0x04, 0x46, 0x91, 0x55, 0x57, 0x07, 0x6D, 0xD9, 0xCD, 0xAE, 0x4F, 0x55, 0x5D, 0x59, 0x87, 0xAE, 0xB9, 0xD5, 0x6D, 0x5B, 0xDB, 0x7D, 0x93, 0xB6, 0xED, 0xEE, 0xE3, 0x5A, 0x6B, 0x6A, 0xF4, 0x91, 0xD5, 0x73, 0x6B, 0x67, 0xF5, 0x47, 0xBC, 0xD4, 0xA7, 0x9C, 0xA5, 0x34, 0xE4, 0xD0, 0xA6, 0xF0, 0xE4, 0xAA, 0xB8, 0x2D, 0xAB, 0xC3, 0x9B, 0x62, 0xC2, 0xAC, 0x74, 0xF6, 0x9F, 0xFB, 0x72, 0x0B, 0xEC, 0x92, 0xCD, 0xEE, 0xCF, 0x43, 0x69, 0x4C, 0x5B, 0xFF, 0x3F};
const uint8_t spREADY[]         PROGMEM = {0x6A,0xB4,0xD9,0x25,0x4A,0xE5,0xDB,0xD9,0x8D,0xB1,0xB2,0x45,0x9A,0xF6,0xD8,0x9F,0xAE,0x26,0xD7,0x30,0xED,0x72,0xDA,0x9E,0xCD,0x9C,0x6D,0xC9,0x6D,0x76,0xED,0xFA,0xE1,0x93,0x8D,0xAD,0x51,0x1F,0xC7,0xD8,0x13,0x8B,0x5A,0x3F,0x99,0x4B,0x39,0x7A,0x13,0xE2,0xE8,0x3B,0xF5,0xCA,0x77,0x7E,0xC2,0xDB,0x2B,0x8A,0xC7,0xD6,0xFA,0x7F};
const uint8_t spSET[]           PROGMEM = {0x08,0xF8,0x35,0x95,0x03,0x02,0xF8,0xC5,0x58,0x03,0x16,0xB0,0xC0,0x2A,0xA6,0x08,0x13,0xD7,0xCE,0xA7,0xEC,0xAE,0xD5,0xCC,0xD6,0xDC,0xEA,0x54,0x35,0xA6,0xA4,0xE5,0x9A,0x3D,0xCC,0x25,0x2E,0x08,0x14,0xA1,0xDC,0x45,0x64,0x03,0x00,0x30,0x60,0x88,0x30,0x05,0xFC,0x1C,0x25,0x80,0x65,0xB6,0x10,0x50,0xA2,0xD0,0xFF,0x03};
const uint8_t spCOMPLETE[]      PROGMEM = {0x0E,0x68,0xA1,0x43,0x03,0xA7,0x2E,0xB2,0x22,0x0B,0xBB,0xDC,0x76,0x75,0x55,0x99,0xB7,0x53,0xB4,0xD1,0x77,0xA6,0x1C,0xA5,0xD6,0x7A,0x9F,0xFA,0x44,0x39,0x5A,0xDC,0x1E,0x9D,0x0C,0x50,0x94,0xB8,0x01,0x46,0x14,0x2F,0x69,0x97,0x9C,0x69,0xA6,0xE4,0x14,0x8D,0x85,0xBB,0x73,0xB3,0x93,0x75,0x6D,0xA2,0x29,0x6F,0x56,0xD6,0xB3,0xB2,0xA8,0x3F,0x59,0xF9,0x18,0x4E,0xA4,0xBE,0x66,0xB6,0x69,0x9F,0xB9,0x08,0xD2,0xDE,0xC4,0x1D,0x81,0x22,0x94,0xBB,0x88,0x6C,0x00,0x00,0x05,0x1C,0xD9,0x6E,0x80,0x65,0x7E,0x18,0xD0,0xEB,0x3A,0x02,0x6A,0x09,0xFC,0x7F};
const uint8_t spTEMPERATURE[]   PROGMEM = {0x0E,0xF8,0x2E,0x2C,0x00,0xCB,0x8F,0x8F,0xA8,0x59,0x15,0xF7,0x58,0x79,0xD2,0x9A,0x5D,0x22,0xB5,0xF5,0x4D,0x47,0x96,0xAB,0x5A,0x87,0x69,0x0E,0x85,0xF7,0x46,0x1D,0xA1,0x0C,0x10,0xE0,0x32,0xBB,0x04,0x56,0x5E,0x62,0x91,0xA6,0x79,0xEF,0x7D,0xEC,0xC1,0x00,0x63,0x6C,0x46,0xC0,0x03,0x16,0x18,0x7D,0x8F,0x29,0x68,0x96,0xB5,0x4D,0x25,0x27,0x71,0x85,0xF7,0xBE,0xF6,0xBD,0x9F,0xF5,0x09,0x77,0x59,0xC2,0xDE,0x9A,0x27,0xBE,0xFE,0xFD,0x7F};
const uint8_t spSTOP[]          PROGMEM = {0x0C,0xF8,0xA5,0x4C,0x02,0x1A,0xD0,0x80,0x04,0x38,0x00,0x1A,0x58,0x59,0x95,0x13,0x51,0xDC,0xE7,0x16,0xB7,0x3A,0x75,0x95,0xE3,0x1D,0xB4,0xF9,0x8E,0x77,0xDD,0x7B,0x7F,0xD8,0x2E,0x42,0xB9,0x8B,0xC8,0x06,0x60,0x80,0x0B,0x16,0x18,0xF8,0x7F};
const uint8_t spMACHINE[]       PROGMEM = {0xC2,0x56,0x3C,0x7D,0xDC,0x12,0xDB,0x3E,0x8C,0x89,0xBA,0x4C,0x4A,0x96,0xD3,0x75,0x95,0x12,0x6E,0xBD,0x6F,0xB7,0xBA,0x16,0x5A,0x58,0x3D,0xB3,0x03,0xA6,0x14,0x76,0xC0,0xCC,0x37,0x11,0xC8,0x40,0x04,0x22,0xB0,0x92,0xD9,0x9A,0xC1,0x7D,0xF5,0xCD,0x6F,0x3E,0x8A,0x39,0x14,0xA5,0x72,0xD4,0x28,0x67,0x56,0xD4,0x89,0xD2,0xB3,0xE9,0x63,0x5D,0xD2,0xDA,0x03,0x49,0xA9,0xDB,0xCD,0x47,0x3C,0xE3,0xEB,0xBF,0xF4,0x75,0x57,0xEC,0xEE,0x9B,0xF2,0x9B,0xBE,0x56,0x34,0xCC,0xA2,0xF2,0xFF,0x03};
const uint8_t spBYE[]               PROGMEM ={0xAE,0xC2,0xA6,0xCC,0x2D,0xD2,0x9E,0xC2,0xA7,0x78,0x91,0xC8,0x74,0xAB,0x53,0xB9,0x34,0xA3,0x30,0x8E,0x6F,0x75,0xAB,0x5B,0x9D,0xDA,0x95,0x6E,0x93,0xB1,0x7F,0xEB,0xDB,0xAC,0x2E,0x4C,0x4B,0xC9,0x96,0xDC,0xBB,0xD6,0x85,0xE2,0x61,0x19,0xA5,0x5B,0x1F,0x8A,0xA9,0x77,0x44,0xEE,0x7D,0xEE,0x62,0x2F,0xFB,0x07,0x00,0x00};
const uint8_t spCONTROL[]       PROGMEM = {0x06,0x68,0xA5,0xCD,0x02,0x2B,0xA9,0x36,0xD5,0x43,0x5A,0x9F,0xA6,0xA9,0x36,0x4F,0xEE,0x73,0xDA,0xC1,0xDA,0x35,0x79,0x73,0x6B,0x9B,0x62,0xEA,0xB0,0x78,0xB3,0x4B,0x7D,0x91,0x18,0xED,0xE6,0x16,0x81,0x22,0x94,0xBB,0x88,0x6C,0x10,0x40,0x0B,0xE1,0x1E,0x88,0xC0,0x48,0x53,0xE2,0x0A,0x17,0x67,0x3B,0x3B,0x59,0xB2,0x11,0x95,0xA2,0x7C,0x64,0x91,0x4F,0x47,0x92,0xF7,0x99,0xAF,0xA2,0xE0,0xEE,0x76,0x56,0xBF,0x9B,0x39,0xB4,0x29,0xB1,0x9C,0x76,0xF4,0x56,0xD7,0xBA,0xE5,0x3B,0x3F,0xF1,0x29,0x77,0xE6,0x9D,0x63,0x9C,0xE7,0xFF,0x01};
const uint8_t spEXIT[]          PROGMEM = {0x6B,0x68,0xC1,0x24,0xAD,0xEE,0xAC,0xA6,0xE7,0x66,0x57,0x7F,0x73,0x9B,0x5B,0xB6,0xA2,0x1F,0x56,0xC5,0x69,0x6A,0xDA,0x96,0x94,0x02,0xB2,0x89,0x02,0x9A,0x1C,0x35,0xC0,0xCF,0x99,0x16,0xB0,0x80,0x04,0xDA,0x5C,0x83,0x4A,0xF0,0xDC,0x5E,0x5B,0x33,0x49,0xA1,0xFE,0xB9,0x9F,0xE1,0x6B,0x41,0x39,0xD8,0x1E,0x23,0x50,0x84,0x72,0x17,0x91,0x0D,0x00,0x02,0x38,0xCC,0xDC,0x02,0x04,0x18,0xF6,0xF3,0xFF,0x01};
const uint8_t spMANUAL[]        PROGMEM = {0x6E,0x8A,0x42,0x6C,0xD5,0x9A,0xA4,0xB1,0x72,0xA5,0x2A,0x49,0x5B,0x87,0xD3,0x75,0x5B,0x1A,0x2E,0xAB,0x6F,0x7D,0xAB,0x53,0x76,0xDF,0x12,0xE6,0xAF,0x6F,0x71,0x8A,0x1E,0x43,0x52,0x72,0xF1,0x2A,0x7A,0x24,0x4D,0x4E,0xD7,0xA5,0x6A,0x06,0x32,0x2D,0x34,0x8F,0x7A,0x24,0x12,0x97,0x4E,0xB8,0xFA,0xE1,0x1D,0xD5,0xB3,0xE1,0x1A,0x7A,0x0D,0x12,0xB5,0xD5,0x6B,0xAC,0x51,0x24,0xD4,0x56,0x97,0x25,0x5A,0xB3,0x32,0x59,0x93,0xB6,0xA8,0x27,0x3C,0x31,0x4F,0xDE,0xEB,0x5E,0xCF,0x72,0x26,0x3E,0xD5,0xC6,0xF9,0xCA,0x55,0x71,0x77,0x39,0x7B,0x2B,0xD7,0x40,0xD1,0x1D,0xAC,0xBD,0xDC,0x05,0x57,0x77,0x90,0xB7,0xFC,0xFC,0x3F};
const uint8_t spMOVE[]          PROGMEM = {0x6A,0xD7,0xC2,0xF2,0xD2,0xEC,0xB8,0x39,0x08,0xF6,0x4D,0x4D,0x1A,0xC6,0x24,0x31,0xB2,0xCC,0x69,0x1E,0x56,0x9D,0x85,0x7B,0x15,0xA4,0x3B,0x55,0x23,0x9E,0x3E,0xE0,0x6D,0xE7,0x23,0xAF,0x20,0xC6,0x0A,0xBC,0xCE,0xA2,0x34,0x91,0x6C,0x89,0x43,0xDF,0x3A,0x94,0x31,0x83,0x6E,0x4D,0xE8,0x9A,0x96,0x0C,0x3A,0x63,0x20,0x5B,0xD8,0xAC,0xEC,0xC8,0x20,0x37,0x7E,0xB7,0xA7,0x3D,0xCD,0xD9,0x8A,0x78,0x28,0x2E,0xB5,0x97,0xBD,0xED,0xCD,0x80,0x52,0x32,0x28,0x80,0x81,0xFF,0x07};
const uint8_t spCIRCUIT[]       PROGMEM = {0x02,0x78,0x2D,0x55,0x02,0x12,0xB0,0x80,0x01,0x5E,0x49,0x5D,0x49,0x35,0xAE,0x1A,0xD6,0xF6,0x94,0x25,0x05,0x5B,0x4A,0xD7,0x55,0x94,0x3C,0x28,0x2D,0xFE,0x76,0x11,0xCA,0xEA,0x06,0x25,0x35,0x29,0x02,0x45,0x28,0x77,0x11,0xD9,0x08,0x28,0x4E,0x15,0x1C,0x50,0x1C,0xD3,0xEA,0x6A,0x14,0x49,0xF7,0x4D,0x7B,0x19,0x67,0x53,0x45,0x65,0xB1,0xA7,0x3E,0x08,0x14,0xA1,0xDC,0x45,0x64,0x03,0x80,0x00,0x96,0x56,0x53,0xC0,0x1F,0xAD,0x02,0x78,0xAE,0x06,0x01,0xCB,0xB7,0xFF,0x3F};
const uint8_t spPOSITION[]      PROGMEM = {0x02,0xC8,0x3C,0x78,0x24,0x5D,0xB8,0xBB,0x53,0xB7,0x5B,0xDC,0x62,0xD5,0x4B,0x38,0x87,0xA1,0x1F,0x05,0x5C,0x40,0x66,0x81,0x95,0x1D,0x19,0xA6,0x4E,0x7E,0x4E,0x3C,0x75,0xA8,0x39,0xF5,0x3D,0x51,0xB7,0xA9,0xA6,0xBA,0xE7,0x44,0x2D,0x99,0x2A,0xC7,0xA6,0x04,0x8C,0x3E,0x95,0x81,0x0C,0x78,0xA0,0xF5,0x2D,0xA8,0x98,0xD9,0x96,0x3D,0x8D,0x69,0xE8,0x64,0x4B,0xE9,0x3B,0x8E,0xA1,0x9D,0xBD,0xA4,0x4B,0x3B,0xBA,0x16,0x2C,0x77,0x7B,0xF9,0xCA,0x4F,0x78,0x7B,0x20,0x35,0x0B,0xA7,0xF1,0xFF,0x7F};
const uint8_t spCAUTION[]       PROGMEM = {0x02,0x48,0x69,0x4D,0x03,0x06,0xE8,0x34,0xA2,0x85,0x95,0x4C,0x78,0xA8,0xD2,0x93,0x66,0xB1,0xE9,0x4D,0x79,0x6F,0x7A,0xD3,0x9D,0xF5,0xCC,0x01,0x2B,0x86,0x06,0x60,0xC5,0xAB,0x08,0x44,0x20,0x00,0xCD,0x10,0x8D,0xB6,0x26,0x11,0x8B,0xE8,0x3C,0xE6,0x62,0x5D,0x3D,0x63,0xF7,0x58,0xBB,0x4E,0xF1,0xB0,0x2E,0xED,0x28,0xCA,0x74,0xCC,0x9B,0xB8,0xB7,0x69,0xA6,0x0E,0x8F,0x66,0xBE,0xAC,0x48,0xC6,0xAD,0xAE,0xFB,0x9A,0x16,0x0E,0xF3,0x78,0xFE,0xF3,0xBF,0xFF,0xED,0xFF,0xFF};
const uint8_t spLIGHT[]         PROGMEM = {0x61,0x69,0xC0,0x2B,0x82,0xB3,0xA5,0x79,0x01,0x9A,0x52,0x71,0x57,0xC7,0x31,0x0C,0x5C,0x5D,0xC1,0x59,0x6F,0x7B,0x9A,0xC6,0x3B,0xCB,0xA5,0xCB,0xA9,0xAA,0x6D,0x6B,0xB3,0xCD,0xA7,0x6C,0x29,0xB4,0x34,0x56,0xAF,0xBA,0x0F,0x23,0x93,0x5C,0x32,0xC7,0xB6,0xF6,0x46,0xA4,0x39,0xB3,0xF3,0x86,0x40,0x11,0xCA,0x5D,0x44,0x36,0x00,0x80,0x02,0x96,0x2A,0x35,0xC0,0xB6,0x97,0x0C,0xE8,0xF9,0x04,0x01,0xC5,0x19,0xFC,0x3F};
const uint8_t spCALIBRATE[]     PROGMEM = {0x0E,0x18,0xC9,0xD9,0x01,0x55,0x29,0x9E,0xA0,0x16,0x97,0x70,0x5F,0x7C,0xB2,0xAA,0xDB,0x2B,0x79,0xCD,0xCD,0x56,0x51,0xC9,0x54,0x0D,0x26,0x1E,0x45,0xC3,0x55,0xDE,0xE2,0xF8,0x54,0xC5,0x94,0xA7,0x73,0x97,0xDB,0x94,0x3E,0xE9,0x52,0x2F,0xF6,0xC2,0x16,0xA9,0x4B,0xB3,0xCC,0x5E,0xD8,0xAA,0x34,0x31,0x73,0x27,0xE5,0x4C,0x8D,0xC3,0xD3,0xF4,0xF6,0xA9,0x2F,0xEB,0xA8,0x2E,0x39,0x42,0xFB,0x8E,0xAB,0x99,0xA4,0x28,0xFF,0x5C,0xEE,0x69,0x97,0x28,0x7D,0x4F,0x7D,0xD2,0xDF,0xAB,0x92,0x98,0x6F,0x41,0x8F,0x08,0xE5,0x2E,0x22,0x1B,0x00,0x18,0xB0,0x42,0xA4,0x02,0x5E,0xA8,0x26,0xC0,0xF0,0xE7,0xFF,0x0F};
const uint8_t spSAFE[]          PROGMEM = {0x08,0xF8,0x39,0x4C,0x02,0x1A,0xD0,0x80,0x05,0x3C,0x60,0x81,0x95,0x0F,0x15,0xE2,0x6A,0xAB,0x4F,0xD1,0x43,0x8A,0x8A,0xBF,0xB9,0xD5,0xAD,0x57,0x3F,0xAA,0x23,0xBB,0x3F,0x9E,0xCB,0xDC,0xF3,0x99,0x9E,0x5E,0x19,0xCD,0xEB,0x8E,0x79,0x7A,0x43,0x13,0xED,0x39,0x0C,0x18,0x7E,0x5C,0x02,0x12,0x90,0x00,0x07,0x28,0x40,0x81,0xFF,0x07};
const uint8_t spCHOICE[]            PROGMEM ={0x06,0x98,0xA9,0x2A,0x03,0x16,0x40,0x00,0x9B,0x9D,0x2B,0xB6,0x26,0x3B,0x92,0xF3,0xEE,0x64,0xA7,0x2B,0x8B,0x3A,0xC7,0x83,0xB3,0xED,0x6A,0xD5,0x31,0x8E,0x7A,0x50,0xE7,0xD9,0xB5,0x21,0x99,0x74,0x2D,0x6F,0x5C,0x06,0x5F,0x9C,0xD2,0x3B,0x4A,0x18,0x63,0x70,0x11,0x89,0x19,0x04,0xF8,0x5E,0x48,0x03,0x1A,0xB0,0x80,0x06,0x24,0x40,0x81,0x07,0x00,0x00};
const uint8_t spCONNECTED[]         PROGMEM ={0x0E,0x88,0xC7,0x35,0x00,0x31,0x15,0x7B,0x20,0x24,0xB1,0x78,0x5A,0xD8,0x92,0x9B,0x9F,0xDC,0xE7,0x70,0x53,0x9F,0x93,0x72,0xEF,0x5D,0x1D,0x2D,0x6D,0x2F,0x4E,0x96,0x72,0x84,0x43,0xD5,0x39,0x69,0x6E,0x91,0x86,0xDD,0x66,0xA4,0x69,0x59,0x90,0x8F,0xEB,0x94,0x45,0xED,0xAA,0x62,0x4A,0x78,0x0D,0x00,0x0A,0x90,0x41,0xA3,0x65,0x25,0x9A,0xA3,0xEB,0xB6,0x59,0xEC,0xAA,0xB6,0xA2,0x17,0x26,0x2C,0xC3,0x33,0xC6,0xDE,0xF6,0xAA,0x57,0xD2,0x2D,0x3D,0x1D,0xBA,0xA6,0x44,0x15,0x16,0xC9,0xAC,0xFA,0x18,0x45,0x94,0xA2,0x26,0xC0,0x03,0x00,0x00};
//----------------------------------------------------------------------------------

//----------------------------------------------------------------------------------
//Telescope
//Variables del motor ascensión
volatile int encposA = 0; //marca posición del encoder
volatile int posdesA = 0; //marca posición del encoder que se quiere llegar
volatile int graposA = 0; //grados actuales
volatile int gradesA = 0; //grados al que se quiere llegar
int in1 = 5; //salida 1 del motordriver PWM
int in2 = 22; //salida 2 del motordriver
int pinA0A = 2;

//Variables del motor declinación
volatile int encposB = 0; //marca posición del encoder
volatile int posdesB = 0; //marca posición del encoder que se quiere llegar
volatile int graposB = 0; //grados actuales
volatile int gradesB = 0; //grados al que se quiere llegar
int in3 = 4; //salida 3 del motordriver PWM
int in4 = 24; //salida 4 del motordriver
int pinA0B= 3;

//Variables generales
int N = 100; //número de ranuras del encoder
char incomingByte; // variable para el ciclo del serial
int number1;
int number2; 
String dato;

//#include <LiquidCrystal.h>
// //LCD pantalla

// int rs = 48;
// int e = 7;
// int d4 = 50;
// int d5 = 12; 
// int d6 = 13;
// int d7 = 52; 
// int numero = 0;

// LiquidCrystal lcd(rs, e, d4, d5, d6, d7);

//DHT11 modulo de temperatutra y humedad

#include <DHT.h>
#include <DHT_U.h>
#include <LiquidCrystal_I2C.h>
#include <Wire.h>

LiquidCrystal_I2C lcd(0x27, 16, 2);

#define Type DHT11
int dhtPin = 46;
DHT HT(dhtPin, Type);
int humidity;
float tempC;
float tempF;

// LDR fotocelda

int photocellPin = 0;
int photocellReading;  
String light;


//Moulo  Bluethoot

#include <SoftwareSerial.h>
SoftwareSerial miBT(10,11);

String data_before;
String data;

// void interrupcionA(){ 
//   encposA++;

//   lcd.setCursor(0, 1);
//   lcd.print("Ascention:");
//   lcd.print(encposA*5);
//   }

// void interrupcionB(){ 
//   encposB++;

//   lcd.setCursor(0, 1);
//   lcd.print("Declination:");
//   lcd.print(encposB*5);
//   }

void setup() {
  // put your setup code here, to run once:
  
  HT.begin();
  miBT.begin(9600);
  pinMode(9,OUTPUT); //Salida del parlante
  voice.say(spHELLO);

  lcd.init();
  lcd.backlight();

  Serial.begin(9600);
  lcd.setCursor(0, 0);
  lcd.print("Hi, Im Emmy");
  lcd.setCursor(0, 1);
  lcd.print("Your telescope");

  pinMode(in1, OUTPUT);
  pinMode(in2, OUTPUT);
  pinMode(in3, OUTPUT);
  pinMode(in4, OUTPUT);
  pinMode(pinA0A, INPUT);
  pinMode(pinA0B, INPUT);

  // attachInterrupt(0, interrupcionA, CHANGE); // entrada 2 PWM a la entrada A   del encoder1 
  // attachInterrupt(1, interrupcionB, CHANGE); // entrada 3 PWM a la entrada A del encoder2

}


void loop() {
  //Mide la temperatura y humedad del ambiente
  humidity = HT.readHumidity();
  tempC = HT.readTemperature();
  //tempF = HT.readTemperature(true);
  Serial.print("Relative humidity: ");
  Serial.print(humidity);
  Serial.print("% / Temperature: ");
  Serial.print(tempC);
  Serial.print("C / ");
  delay(1500);

  photocellReading = analogRead(photocellPin);


  if(photocellReading <= 200) {
  //Serial.println("DARK : Analog Value = " + String(photocellReading));
  light = "DARK";
  voice.say(spSAFE);
}
  
  if (photocellReading > 200 && photocellReading <= 500) {
  //Serial.println("DIM LIGHT : Analog Value = " + String(photocellReading)); 
  light = "DIM LIGHT";
  voice.say(spALERT);
  } 
  if (photocellReading > 500 && photocellReading <= 800) {
  //Serial.println("BRIGHT LIGHT : Analog Value = " + String(photocellReading)); 
  light = "BRIGHT LIGHT";
  voice.say(spCAUTION);
  } 
  if (photocellReading > 800) {
  //Serial.println("FULL DAY LIGHT : Analog Value = " + String(photocellReading));
  light = "FULL DAYLIGHT";
  voice.say(spDANGER);
  } 

//Inicia comunicación  bluetoth
if (miBT.available()>0){
  data_before = miBT.readString();

  Serial.print(data_before);
  delay(100);
  }



  else if (data_before == "menu"){
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Insert command");
    // Serial.print("Insert command");
    voice.say(spSET);
    voice.say(spCHOICE);
  }

  

  else if (data_before == "light"){

    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("L: ");
    lcd.print(light);
    delay(500);
  }    
  

  else if (data_before == "weather"){
    
    voice.say(spTEMPERATURE);
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Humidity: ");
    lcd.print(humidity);
    lcd.print("% ");

    lcd.setCursor(0, 1);
    lcd.print("Temp: ");
    lcd.print(tempC);
    lcd.print("C");
    delay(1500);
  }

  else if (data_before == "up"){
  voice.say(spSET);
  voice.say(spMANUAL);
  voice.say(spMOVE);

  lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("UP");
    digitalWrite(in1,LOW);
    digitalWrite(in2,HIGH);
    // interrupcionA();
    delay(20000);

  }

  else if (data_before == "down"){
  voice.say(spSET);
  voice.say(spMANUAL);
  voice.say(spMOVE);

  lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("DOWN");
    digitalWrite(in1,HIGH);
    digitalWrite(in2,LOW);
    // interrupcionA();
    delay(20000);
    } 
  

  else if (data_before == "left"){
  voice.say(spSET);
  voice.say(spMANUAL);
  voice.say(spMOVE);

    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("LEFT");
    digitalWrite(in3,LOW);
  digitalWrite(in4,HIGH);
  // interrupcionB();
  delay(20000);
  }


  else if (data_before == "right"){
  voice.say(spSET);
  voice.say(spMANUAL);
  voice.say(spMOVE);

    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("RIGHT");

    digitalWrite(in3,HIGH);
    digitalWrite(in4,LOW);
    // interrupcionB();
    delay(20000);
    
  
  }

  else if (data_before == "off"){
  voice.say(spSET);
  voice.say(spMANUAL);
  voice.say(spMOVE);
  
  lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("STOP");

    digitalWrite(in1,LOW);
  digitalWrite(in2,LOW);

  digitalWrite(in3,LOW);
  digitalWrite(in4,LOW);
  delay(20000);

   }
   
}
// Funciones para el movimiento de los motores con stellarium




//   else if (data_before == "telescope"){
//     lcd.setCursor(0, 0); 
//     lcd.print("Launch program");
//     lcd.clear();
//     delay(1000);    

//     char digit1 = data_before[0]; // Lee el primer dígito
//     char digit2 = data_before[1]; // Lee el segundo dígito
//     char digit3 = data_before[2]; // Lee el tercer dígito
//     char digit4 = data_before[3]; // Lee el primer dígito
//     char digit5 = data_before[4]; // Lee el segundo dígito
//     char digit6 = data_before[5]; // Lee el tercer dígito
//     // Convierte los caracteres a números enteros
//     int num1 = digit1 - '0';
//     int num2 = digit2 - '0';
//     int num3 = digit3 - '0';
//     int num4 = digit4 - '0';
//     int num5 = digit5 - '0';
//     int num6 = digit6 - '0';

//     // Combina los dos dígitos en un número
//     number1 = num1 * 100 + num2*10 + num3;
//     number2 = num4 * 100 + num5*10 + num6;
//     Serial.println(number1);
//     Serial.println(number2);

//   gradesA = number1;
//   gradesB = number2;

//   lcd.setCursor(0, 0);
//   lcd.print("Ascention:");
//   lcd.print(number1);

//   lcd.setCursor(0, 1);
//   lcd.print("Declination:");
//   lcd.print(number2);

//   lcd.clear();

//   posdesA = round(number1/5);
//   posdesB = round(number2/5);

//   interrupcionA();
//   interrupcionB();

//   }
//   }
// }



//----------------------------------------------------------------
//STELLARIUM

// // //variables del motor de ascension
// int in1 = 5; //salida 1 del motordriver PWM
// int in2 = 22; //salida 2 del motordriver
// // int Ena = 13; //pin PWM para control de velocidad de a

// //variables del motor de declinacion
// int in3 = 4; //salida 3 del motordriver PWM
// int in4 = 24; //salida 4 del motordriver
// // int Enb = 12; //pin PWM para control de velocidad de b

// //variables generales
// int N = 100 ; //número de ranuras del encoder
// char incomingByte; // variable para el ciclo del serial
// int number1;
// int number2; 
// String dato;

// volatile int lastEncoded1 = 0;
// volatile long encoderValue1 = 0;
// volatile int lastEncoded2 = 0;
// volatile long encoderValue2 = 0;

// char input[20];
// char txAR[10];
// char txDEC[11];
// long TSL;
// unsigned long t_ciclo_acumulado = 0, t_ciclo;
// long Az_tel_s, Alt_tel_s;
// long AR_tel_s, DEC_tel_s;
// long AR_stell_s, DEC_stell_s;
// double cos_phi, sin_phi;
// double alt, azi;

// //--------------------------------------------------------------------------------------------------------------------------------------------------------
// void setup()
// {
//   Serial.begin(9600);
//   pinMode(in1, OUTPUT);
//   pinMode(in2, OUTPUT);
//   pinMode(in3, OUTPUT);
//   pinMode(in4, OUTPUT);
//   attachInterrupt(0, Encoder1, FALLING); // entrada 2 PWM a la entrada A   del encoder1 
//   attachInterrupt(1, Encoder2, FALLING); // entrada 3 PWM a la entrada A del encoder2

//   cos_phi = cos((((latHH * 3600) + (latMM * 60) + latSS) / 3600.0) * pi / 180.0);
//   sin_phi = sin((((latHH * 3600) + (latMM * 60) + latSS) / 3600.0) * pi / 180.0);

//   TSL = poleAR_HH * 3600 + poleAR_MM * 60 + poleAR_SS + poleH_HH * 3600 + poleH_MM * 60 + poleH_SS;
//   while (TSL >= 86400) TSL = TSL - 86400;
// }

// //--------------------------------------------------------------------------------------------------------------------------------------------------------
// void loop()
// {
//   t_ciclo = millis();
//   if (t_ciclo_acumulado >= seg_sideral) {
//     TSL++;
//     t_ciclo_acumulado = t_ciclo_acumulado - seg_sideral;
//     if (TSL >= 86400) {
//       TSL = TSL - 86400;
//     }
//   }

//   read_sensors();
//   AZ_to_EQ();

//   if (Serial.available() > 0) communication();

//   t_ciclo = millis() - t_ciclo;
//   t_ciclo_acumulado = t_ciclo_acumulado + t_ciclo;
// }

// //--------------------------------------------------------------------------------------------------------------------------------------------------------
// void communication()
// {
//   int i = 0;
//   input[i++] = Serial.read();
//   delay(5);
//   while ((input[i++] = Serial.read()) != '#') {
//     delay(5);
//   }
//   input[i] = '\0';

//   if (input[1] == ':' && input[2] == 'G' && input[3] == 'R' && input[4] == '#') {
//     Serial.print(txAR);
//   }

//   if (input[1] == ':' && input[2] == 'G' && input[3] == 'D' && input[4] == '#') {
//     Serial.print(txDEC);
//   }
// }

// //--------------------------------------------------------------------------------------------------------------------------------------------------------
// void read_sensors() {
//   long h_deg, h_min, h_seg, A_deg, A_min, A_seg;

//   if (encoderValue2 >= pulses_enc2 || encoderValue2 <= -pulses_enc2) {
//     encoderValue2 = 0;
//   }
//   int enc1 = encoderValue1 / 1500;
//   long encoder1_temp = encoderValue1 - (enc1 * 1500);
//   long map1 = enc1 * map(1500, 0, pulses_enc1, 0, 324000);
//   int enc2 = encoderValue2 / 1500;
//   long encoder2_temp = encoderValue2 - (enc2 * 1500);
//   long map2 = enc2 * map(1500, 0, pulses_enc2, 0, 1296000);

//   Alt_tel_s = map1 + map (encoder1_temp, 0, pulses_enc1, 0, 324000);
//   Az_tel_s  = map2 + map (encoder2_temp, 0, pulses_enc2, 0, 1296000);

//   if (Az_tel_s < 0) Az_tel_s = 1296000 + Az_tel_s;
//   if (Az_tel_s >= 1296000) Az_tel_s = Az_tel_s - 1296000 ;

// }

// //--------------------------------------------------------------------------------------------------------------------------------------------------------
// void Encoder1() {
//   int encoded1 = (digitalRead(in1) << 1);
//   int sum  = (lastEncoded1 << 2) | encoded1;
//   if (sum == 0b1101 || sum == 0b0100 || sum == 0b0010 || sum == 0b1011) encoderValue1 ++;
//   if (sum == 0b1110 || sum == 0b0111 || sum == 0b0001 || sum == 0b1000) encoderValue1 --;
//   lastEncoded1 = encoded1;
// }

// //--------------------------------------------------------------------------------------------------------------------------------------------------------
// void Encoder2() {
//   int encoded2 = (digitalRead(in2) << 1);;
//   int sum  = (lastEncoded2 << 2) | encoded2;

//   if (sum == 0b1101 || sum == 0b0100 || sum == 0b0010 || sum == 0b1011) encoderValue2 ++;
//   if (sum == 0b1110 || sum == 0b0111 || sum == 0b0001 || sum == 0b1000) encoderValue2 --;
//   lastEncoded2 = encoded2;
// }

// //--------------------------------------------------------------------------------------------------------------------------------------------------------
// void AZ_to_EQ()
// {
//   double delta_tel, sin_h, cos_h, sin_A, cos_A, sin_DEC, cos_DEC;
//   double H_telRAD, h_telRAD, A_telRAD;
//   long H_tel;
//   long arHH, arMM, arSS;
//   long decDEG, decMM, decSS;
//   char sDEC_tel;

//   A_telRAD = (Az_tel_s / 3600.0) * pi / 180.0;
//   h_telRAD = (Alt_tel_s / 3600.0) * pi / 180.0;
//   sin_h = sin(h_telRAD);
//   cos_h = cos(h_telRAD);
//   sin_A = sin(A_telRAD);
//   cos_A = cos(A_telRAD);
//   delta_tel = asin((sin_phi * sin_h) + (cos_phi * cos_h * cos_A));
//   sin_DEC = sin(delta_tel);
//   cos_DEC = cos(delta_tel);
//   DEC_tel_s = long((delta_tel * 180.0 / pi) * 3600.0);

//   while (DEC_tel_s >= 324000) {
//     DEC_tel_s = DEC_tel_s - 324000;
//   }
//   while (DEC_tel_s <= -324000) {
//     DEC_tel_s = DEC_tel_s + 324000;
//   }

//   H_telRAD = acos((sin_h - (sin_phi * sin_DEC)) / (cos_phi * cos_DEC));
//   H_tel = long((H_telRAD * 180.0 / pi) * 240.0);

//   if (sin_A >= 0) {
//     H_tel = 86400 - H_tel;
//   }
//   AR_tel_s = TSL - H_tel;

//   while (AR_tel_s >= 86400) {
//     AR_tel_s = AR_tel_s - 86400;
//   }
//   while (AR_tel_s < 0) {
//     AR_tel_s = AR_tel_s + 86400;
//   }

//   arHH = AR_tel_s / 3600;
//   arMM = (AR_tel_s - arHH * 3600) / 60;
//   arSS = (AR_tel_s - arHH * 3600) - arMM * 60;
//   decDEG = abs(DEC_tel_s) / 3600;
//   decMM = (abs(DEC_tel_s) - decDEG * 3600) / 60;
//   decSS = (abs(DEC_tel_s) - decDEG * 3600) - decMM * 60;
//   (DEC_tel_s < 0) ? sDEC_tel = 45 : sDEC_tel = 43;

//   sprintf(txAR, "%02d:%02d:%02d#", int(arHH), int(arMM), int(arSS));
//   sprintf(txDEC, "%c%02d%c%02d:%02d#", sDEC_tel, int(decDEG), 223, int(decMM), int(decSS));
// }





